{"version":3,"sources":["../../src/main.js"],"names":[],"mappings":"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","file":"main.js","sourcesContent":["export const toCharCodeArray = (str) => str.split('').map(c => c.charCodeAt(0));\n\n/**\n * Returns a function that generates a Rabin fingerprint hash function\n * @param p The prime to use as a base for the Rabin fingerprint algorithm\n */\nexport const simpleHashFn = (p) => (arrayValues, lastHash, lastCharCode) => {\n  return lastHash ?\n    // See the abracadabra example: https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\n    (lastHash - lastCharCode * Math.pow(p, arrayValues.length - 1)) * p + arrayValues[arrayValues.length - 1] :\n    arrayValues.reduce((total, x, i) => total + x * Math.pow(p, arrayValues.length - i - 1), 0);\n}\n\n/*\n * Sets the specific bit location\n */\nexport const setBit = (buffer, bitLocation) =>\n  buffer[bitLocation / 8 | 0] |= 1 << bitLocation % 8;\n\n/**\n * Returns true if the specified bit location is set\n */\nexport const isBitSet = (buffer, bitLocation) =>\n  !!(buffer[bitLocation / 8 | 0] & 1 << bitLocation % 8);\n\nexport class BloomFilter {\n  /**\n   * Constructs a new BloomFilter instance.\n   * If you'd like to initialize with a specific size just call BloomFilter.from(Array.from(Uint8Array(size).values()))\n   * Note that there is purposely no remove call because adding that would introduce false negatives.\n   *\n   * @param bitsPerElement Used along with estimatedNumberOfElements to figure out the size of the BloomFilter\n   *   By using 10 bits per element you'll have roughly 1% chance of false positives.\n   * @param estimatedNumberOfElements Used along with bitsPerElementto figure out the size of the BloomFilter\n   * @param hashFns An array of hash functions to use. These can be custom but they should be of the form\n   *   (arrayValues, lastHash, lastCharCode) where the last 2 parameters are optional and are used to make\n   *   a rolling hash to save computation.\n   */\n  constructor(bitsPerElement = 10, estimatedNumberOfElements = 50000, hashFns) {\n    if (bitsPerElement.constructor === Uint8Array) {\n      // Re-order params\n      this.buffer = bitsPerElement;\n      if (estimatedNumberOfElements.constructor === Array) {\n        hashFns = estimatedNumberOfElements;\n      }\n      // Calculate new buffer size\n      this.bufferBitSize = this.buffer.length * 8;\n    } else if (bitsPerElement.constructor === Array) {\n      // Re-order params\n      let arrayLike = bitsPerElement;\n      if (estimatedNumberOfElements.constructor === Array) {\n        hashFns = estimatedNumberOfElements;\n      }\n      // Calculate new buffer size\n      this.bufferBitSize = arrayLike.length * 8;\n      this.buffer = new Uint8Array(arrayLike);\n    } else {\n      // Calculate the needed buffer size in bytes\n      this.bufferBitSize = bitsPerElement * estimatedNumberOfElements;\n      this.buffer = new Uint8Array(Math.ceil(this.bufferBitSize / 8));\n    }\n    this.hashFns = hashFns || [simpleHashFn(11), simpleHashFn(17), simpleHashFn(23)];\n    this.setBit = setBit.bind(this, this.buffer);\n    this.isBitSet = isBitSet.bind(this, this.buffer);\n  }\n\n\n  /**\n   * Construct a Bloom filter from a previous array of data\n   * Note that the hash functions must be the same!\n   */\n  static from(arrayLike, hashFns) {\n    return new BloomFilter(arrayLike, hashFns);\n  }\n\n  /**\n   * Serializing the current BloomFilter into a JSON friendly format.\n   * You would typically pass the result into JSON.stringify.\n   * Note that BloomFilter.from only works if the hash functions are the same.\n   */\n  toJSON() {\n    return Array.from(this.buffer.values());\n  }\n\n  /**\n   * Print the buffer, mostly used for debugging only\n   */\n  print() {\n    console.log(this.buffer);\n  }\n\n  /**\n   * Given a string gets all the locations to check/set in the buffer\n   * for that string.\n   * @param charCodes An array of the char codes to use for the hash\n   */\n  getLocationsForCharCodes(charCodes) {\n    return this.hashFns.map(h => h(charCodes) % this.bufferBitSize);\n  }\n\n  /**\n   * Obtains the hashes for the specified charCodes\n   * See \"Rabin fingerprint\" in https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm for more information.\n   *\n   * @param charCodes An array of the char codes to use for the hash\n   * @param lastHashes If specified, it will pass the last hash to the hashing\n   * function for a faster computation.  Must be called with lastCharCode.\n   * @param lastCharCode if specified, it will pass the last char code\n   *  to the hashing function for a faster computation. Must be called with lastHashes.\n   */\n  getHashesForCharCodes(charCodes, lastHashes, lastCharCode) {\n    return this.hashFns.map((h, i) => h(charCodes, lastHashes ? lastHashes[i] : undefined, lastCharCode, this.bufferBitSize));\n  }\n\n  /**\n   * Adds he specified string to the set\n   */\n  add(data) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n\n    this.getLocationsForCharCodes(data).forEach(this.setBit);\n  }\n\n  /**\n   * Checks whether an element probably exists in the set, or definitely doesn't.\n   * @param str Either a string to check for existance or an array of the string's char codes\n   *   The main reason why you'd want to pass in a char code array is because passing a string\n   *   will use JS directly to get the char codes which is very inneficient compared to calling\n   *   into C++ code to get it and then making the call.\n   *\n   * Returns true if the element probably exists in the set\n   * Returns false if the element definitely does not exist in the set\n   */\n  exists(data) {\n    if (data.constructor !== Array) {\n      data = toCharCodeArray(data);\n    }\n    return this.getLocationsForCharCodes(data).every(this.isBitSet);\n  }\n\n  /**\n   * Checks if any substring of length substringLenght probably exists or definitely doesn't\n   * If false is returned then no substring of the specified string of the specified lengthis in the bloom filter\n   * @param data The substring or char array to check substrings on.\n   */\n  substringExists(data, substringLength) {\n    if (data.constructor !== Uint8Array) {\n      if (data.constructor !== Array) {\n        data = toCharCodeArray(data);\n      }\n      data = new Uint8Array(data);\n    }\n\n    let lastHashes, lastCharCode;\n    for (let i = 0; i < data.length - substringLength + 1; i++) {\n\n      lastHashes = this.getHashesForCharCodes(data.subarray(i, i + substringLength), lastHashes, lastCharCode);\n      if (lastHashes.map(x => x % this.bufferBitSize).every(this.isBitSet)) {\n        return true;\n      }\n      lastCharCode = data[i];\n    }\n    return false;\n  }\n}\n"]}